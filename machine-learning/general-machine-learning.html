<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
        <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
        <title>机器学习中的基本概念 - tracholar's personal knowledge wiki</title>
        <meta name="keywords" content="technology, machine learning, data mining, economics, accounting"/>
        <meta name="description" content="A wiki website of tracholar when I learned new knowledgy and technics."/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width" />

        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$(',')$'], ['\\(','\\)']]}
        });
        </script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-78529611-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/wiki/">Home</a>&nbsp;»&nbsp;<a href="/wiki/#machine-learning">machine-learning</a>&nbsp;»&nbsp;机器学习中的基本概念</div>
</div>
<div class="clearfix"></div>
<div id="title">机器学习中的基本概念</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">关于</a></li>
<li><a href="#_2">基础统计分布</a><ul>
<li><a href="#_3">几种常见的分布</a></li>
<li><a href="#_4">正态分布的和</a></li>
<li><a href="#_5">卡方分布</a></li>
<li><a href="#student-t">student-t 分布</a></li>
<li><a href="#f">F分布</a></li>
<li><a href="#tf">卡方分布、t分布、F分布的联系</a></li>
<li><a href="#_6">参考</a></li>
</ul>
</li>
<li><a href="#_7">统计检验</a><ul>
<li><a href="#_8">方差统计</a></li>
<li><a href="#_9">卡方统计</a></li>
<li><a href="#f-classif">F classif</a></li>
<li><a href="#f-regression">F regression</a></li>
</ul>
</li>
<li><a href="#_10">特征变换</a><ul>
<li><a href="#hash">特征Hash</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="_1">关于</h2>
<p>记录机器学习中的基本问题和概念。</p>
<h2 id="_2">基础统计分布</h2>
<h3 id="_3">几种常见的分布</h3>
<p>包括正态分布、泊松分布、指数分布等。略，后面可能会写。</p>
<h3 id="_4">正态分布的和</h3>
<p>两个服从正太分布的随机变量 $(X_1, X_2)$， 只要其联合分布为正态分布，那么和也为正态分布。</p>
<h3 id="_5">卡方分布</h3>
<p>设$(X_1,...,X_n)$ iid，服从标准正态分布，那么平方和$(X_1^2+...+X_n^2)$服从自由度为n的卡方分布。</p>
<p>卡方分布的和： $(X_1,X_2)$独立，$(X_1 \sim \chi_m^2, X_2 \sim \chi_n^2)$，那么 $(X_1+X_2 \sim \chi_{n+m}^2)$</p>
<h3 id="student-t">student-t 分布</h3>
<p>$(X_1,X_2)$独立，且$(X_1\sim\chi_n^2, X_2 \sim N(0,1))$，那么$(X_2 / \sqrt{X_1/n})$服从自由度为n的t分布。<br />
一个例子，从正态分布总体采样的n+1个样本均值对样本标准差归一化后的值服从自由度为n的t分布。</p>
<h3 id="f">F分布</h3>
<p>$(X_1\sim\chi_n^2, X_2\sim\chi_m^2)$且统计独立，那么$(m^{-1} X_2 / (n^{-1} X_1))$服从自由度为$((m,n))$的F分布</p>
<p>由于F分布是两个卡方分布的比值，而卡方分布是正态分布的平方和，常出现在方差之中，所以F分布在方差分析之中被大量使用。</p>
<h3 id="tf">卡方分布、t分布、F分布的联系</h3>
<p>设 $(X_1,...,X_n,Y_1,...,Y_m)$独立同分布(iid)，服从标准正态分布，记 $(\bar{X} = (X_1+...+X_n)/n)$，<br />
$(S^2=\sum_i (X_i - \bar{X})^2/(n-1))$，则：       </p>
<ol>
<li>$((n-1)S^2)$服从自由度为n-1的卡方分布</li>
<li>$(\sqrt{n}\bar{X}/S)$服从自由度为n-1的t分布</li>
<li>$([S_Y^2/(m-1)]/[S_X^2/(n-1)])$服从自由度为(m-1,n-1)的F分布</li>
</ol>
<h3 id="_6">参考</h3>
<ul>
<li>陈希孺，概率论与数理统计，中国科学技术大学出版社</li>
<li><a href="https://en.wikipedia.org/wiki/Cochran%27s_theorem#Sample_mean_and_sample_variance">Cochran theaream</a></li>
</ul>
<h2 id="_7">统计检验</h2>
<h3 id="_8">方差统计</h3>
<p>去掉方差太小的特征。</p>
<h3 id="_9">卡方统计</h3>
<p>卡方检验，也称独立性检验，拟合优度检验。使用要求，自变量为正值。<br />
<code>sklearn</code>中用来检验正值特征与目标是否独立，从而进行特征选择。</p>
<p>例如变量 X 为性别（男0，女1），变量 Y 为是否为左撇子（否 0, 是 1) 。对于某个样本，<br />
有列联表：</p>
<table>
<thead>
<tr>
<th></th>
<th>男</th>
<th>女</th>
<th>总计</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td>43</td>
<td>44</td>
<td>87</td>
</tr>
<tr>
<td>是</td>
<td>9</td>
<td>4</td>
<td>13</td>
</tr>
<tr>
<td>总计</td>
<td>52</td>
<td>48</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>从数据中，可以看到几个边缘分布：</p>
<p>$$<br />
P(男) = 0.52, P(女) = 0.48 \\<br />
P(否) = 0.87, P(是) = 0.13<br />
$$</p>
<p>如果两个变量是独立的，那么列联表里面的分布应该由式</p>
<p>$$<br />
P(X, Y) = P(X) P(Y)<br />
$$</p>
<p>得到，我们将这个值作为期望值，记作$(E_{i,j})$，而将实际值记作$(O_{i,j})$，例如，男性不是左撇子的期望值为<br />
$(E_{1,1} = 100 * 0.52*0.87 = 45)$，而观测值为$(O_{1,1} = 43)$。</p>
<p>利用上述符号，定义统计量     <br />
$$<br />
\chi^2 = \sum_{i=1}^r \sum_{j=1}^c \frac{(O_{i,j} - E_{i,j})^2}{E_{i,j}}<br />
$$</p>
<p>则它近似服从自由度为$((r-1)(c-1))$的卡方分布（理论呢？）。该统计量越小，说明越符合独立分布，因此，变量间越独立。</p>
<p>如果其中一个是连续值，<code>sklearn</code>中是将连续值求和，然后用类的分布概率乘以该值作为期望值，而实际不同类求和的值作为观测值，然后求卡方值。</p>
<div class="hlcode"><pre><span class="c">## Y是类别的one-hot编码，X是特征</span>
<span class="n">observed</span> <span class="o">=</span> <span class="n">safe_sparse_dot</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>          <span class="c"># n_classes * n_features</span>
<span class="n">feature_count</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">class_prob</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">class_prob</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">feature_count</span><span class="p">)</span>
</pre></div>


<h3 id="f-classif">F classif</h3>
<p>ANOVA F-value</p>
<p>连续变量与类别变量之间的独立性检验，只要求为正态分布。</p>
<p>统计检验量是样本在各个分组之间的差异(between-group mean square value)与组内的差异之和(within-group mean of squares)的比值。<br />
组间差异是指每个样本用它所在组的均值替换，然后汇总每个样本与样本均值的差的平方，最后除以自由度。<br />
而组内差异是指直接计算每个样本与该组样本均值的差的平方，最后除以自由度。</p>
<p>如果自变量对因变量没有显著影响，那么这个比值应该接近于1，反之将远大于1.</p>
<p>$$<br />
MSB = \frac{1}{K-1}\sum_{i,j} (\bar{Y_i} - \bar{Y})^2  \\<br />
MSW = \frac{1}{K(N-1)}\sum_{i,j} (Y_{i,j} - \bar{Y_i})^2 \\<br />
F = MSB / MSW<br />
$$</p>
<p>这里$(K,N)$分别是分组数目（或者分类类别数目）和每组样本数目，分母其实是自由度。<br />
最后得到的统计检验量服从自由度为(K-1,K(N-1))的F分布。</p>
<p>参考<a href="https://en.wikipedia.org/wiki/F-test#One-way_ANOVA_example">wikipedia</a></p>
<h3 id="f-regression">F regression</h3>
<p>Univariate linear regression tests</p>
<p>构建很多个单因素的线性回归检验.</p>
<ul>
<li>SST 总的平方差之和 $(\sum (Y - \bar{Y})^2)$</li>
<li>SSM 模型的平方差之和 $(\sum (Y_{pred} - \bar{Y})^2)$</li>
<li>SSR 残余的平方差之和 SST - SSM.</li>
<li>MSM 模型均方差 SSM / SSM的自由度</li>
<li>MSR 残余均方差 SSR / SSR的自由度</li>
</ul>
<p>$$<br />
R^2 = SSM / SST  \\<br />
F =  MSM / MSR<br />
$$</p>
<p>如果自变量与因变量没有明显的关系，那么F值应该很小。</p>
<p>参考 <a href="http://homepages.inf.ed.ac.uk/bwebb/statistics/Univariate_Regression.pdf">http://homepages.inf.ed.ac.uk/bwebb/statistics/Univariate_Regression.pdf</a></p>
<h2 id="_10">特征变换</h2>
<h3 id="hash">特征Hash</h3>
<p>一种快速的空间效率高的向量化特征的方法。Yahoo 研究院的Weinberger与ICML2009提出。<br />
<a href="http://www.machinelearning.org/archive/icml2009/papers/407.pdf">Feature Hashing for Large Scale Multitask Learning</a></p>
<p>Hash 算法是一种有效的特征降维的方法，非参数估计。可以用来做 multitask learning with hundreds of<br />
thousands of tasks！！！</p>
<p>核方法 kernel trick：$(x_1,...,x_n \in X)$，半正定核</p>
<p>$$<br />
k(x_1, x_2) = (\phi(x_1), \phi(x_2))<br />
$$</p>
<p>这种方法可以将原空间非线性决策边界变成变换后空间的线性可分的界。（SVM）<br />
相反的问题是，如果问题在原空间是现行可分的（通常是通过人工的非线性特征工程实现），<br />
但是特征的维度很高。作者提出一种和 kernel trick 互补的方法 hash trick，<br />
将高维空间$(R^d)$特征映射到低维空间$(R^m)$，$(\phi(x) \to R^m)$（Langford et al., 2007; Shi et al., 2009）。<br />
并且有$(m &lt;&lt; d)$。<br />
不同于 <strong>随机投影？</strong> ， hash trick 解决了稀疏性，也不需要额外的存储空间存储核矩阵。</p>
<p>hash 内积</p>
<p>hash trick 在 multi-task learning 场景下很有用，这里原始特征是数据集的交叉积 cross product。<br />
每一个任务 U 可以采用不同的hash 函数$(\phi_1(x),...,\phi_{|U|}(x))$，另外共享一个通用的hash函数$(\phi_0(x))$。</p>
<p>以垃圾邮件分类为例，每一个用户需要有他自己的个性化偏好，这里的任务集 U 是针对所有用户（对于 Yahoo mail 和 Gmail数目很大）。<br />
特征空间是大量的语言的词汇集合。</p>
<p>论文的主要贡献：</p>
<ol>
<li>专门实现的任意内积hash函数，可以应用到许多 kernel method</li>
<li>指数界解释</li>
<li>独立hash子空间使得大规模 multi-task learning 空间使用很小</li>
<li>实际的协同垃圾邮件过滤系统</li>
</ol>
<p>Hash 函数：</p>
<p>hash 函数 $(h: \mathbb{N} \to \{1,...,m\})$，另一个hash函数$(\xi : \mathbb{N} \to \{\pm 1\})$.<br />
对于向量 $(x,x' \in l_2)$，定义hash 特征映射</p>
<p>$$<br />
\phi_i^{(h, \xi)} = \sum_{j: h(j)=i} \xi(j) x_j \\<br />
\langle x, x' \rangle_{\phi} = \langle  \phi^{(h, \xi)}(x), \phi^{(h, \xi)}(x') \rangle<br />
$$</p>
<p>这里的hash函数定义在自然数集上，实际上对字符串也成立，因为有限长字符串都可以表示为一个自然数。</p>
<p>个人理解：举例，假设h是一个求余函数，那么特征映射后的低维空间的每一个分量相当于将向量等间隔的分量交替求和，从而实现降维。</p>
<p>引理： hash kernel 是无偏的，如果 $(E_{\phi} [\langle x, x' \rangle_{\phi}] = \langle x, x' \rangle)$。<br />
并且方差 $(\sigma_{x,x'}^2 = \frac{1}{m} \sum_{i\neq j} x_i^2 x_j^{'2} + x_i x_i' x_j x_j')$，如果原始向量<br />
都是标准化的，即二范数为1，那么方差为$(O({\frac{1}{m}}))$。</p>
<p>略去若干理论和证明，后面有需要再来看。</p>
<p>Multiple Hashing</p>
<p>近似正交性：对于multi-task learning，需要学习不同的权值，当映射到同一个空间时，需要参数空间交叉部分尽可能少。<br />
设$(w \in R^m)$是$( U \ {u})$中的某个任务的参数向量，对任意特征$(x \in u)$，$(w)$ 和 $(\phi_u(x))$的内积很小。</p>
<p>应用：减少存储，避免矩阵向量乘法运算 Locality Sensitive Hashing ？</p>
<p>个性化：每一个task更新局部(local)权值和全局(global)权值。正交性让我们可以将这些特征hash到同一个空间，而没有太多的重叠部分。</p>
<p>邮件过滤问题：每个用户有一些标记数据，但是很少，如果对每一个用户单独训练一个模型$(w_u)$（模型参数？），将缺乏数据而使模型不可用。<br />
可以通过一个全局模型$(w_0)$使得数据能够在多个分类器中共享。存储所有分类器需要$(O(d (|U| + 1)))$的空间复杂度。<br />
简单的方法是排除低频的token。但这回导致恶意错误拼写的单词被丢弃，而hash到一个低维空间，使得这些低频词也能对模型有所贡献。<br />
而且大规模的邮件过滤器对内存和时间有严格要求，因为用户量太大。为此，我们将权值向量$(w_0, ..., w_{|U})$ 通过不同的映射$(\phi_0,...,\phi_{|U|})$，<br />
映射到低维特征空间$(R^m)$。最终的权值为：</p>
<p>$$<br />
w_h = \phi_0(w_0) + \sum_{u \in U} \phi_u(w_u)<br />
$$</p>
<p>实际上，$(w_h)$可以在低维空间直接学习，重来不需要去计算高维向量。对于用户u新的文档或者邮件x，预测任务变成计算内积$(\langle \phi_0(x) + \phi_u(x), w_h \rangle)$。hash操作将会带来内积的计算的失真$(\epsilon_d)$，其他hash函数带来的重叠$(\epsilon_i)$。</p>
<p>$$<br />
\langle \phi_0(x) + \phi_u(x), w_h \rangle = \langle x, w_0 + w_u \rangle + \epsilon_d + \epsilon_i<br />
$$</p>
<p>大规模协同过滤：$(M = U^T W)$，U和W $(\in R^{nd})$，存储需要大量空间，利用hash只需要两个m维向量$(u, w)$</p>
<p>$$<br />
u_i = \sum_{j,k:h(j,k)=i} \xi(j,k) U_{jk},\\<br />
w_i = \sum_{j,k:h'(j,k)=i} \xi'(j,k) W_{jk}<br />
$$</p>
<p>这里$((h,\xi), (h',\xi'))$是两组独立的hash 函数。近似计算$(M_{ij})$的方法是：</p>
<p>$$<br />
M_{ij}^{\phi} = \sum_k \xi(k,i)\xi'(k,j) u_{h(k,i)} w_{h'(k,j)}<br />
$$</p>
</div>
<div id="content-footer">created in <span class="create-date date"> 2016-07-27 </span></div>
<div id="comments"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script type="text/javascript">
const gitment = new Gitment({
  id: location.pathname,
  title: '机器学习中的基本概念',
  owner: 'tracholar',
  repo: 'wiki',
  oauth: {
    client_id: '0cc0476e504b5e70ae7c',
    client_secret: 'ab98e39ef79469040057eba9c6b2b543b84c72ee',
  },
  // ...
  // For more available options, check out the documentation below
})

gitment.render('comments')
// or
// gitment.render(document.getElementById('comments'))
// or
// document.body.appendChild(gitment.render())
</script>

        </div>
        <div id="footer">
            <span>
                Copyright © 2017 tracholar.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
                Fork me in <a href="https://github.com/tracholar/wiki" target="_blank"> github </a>.
            </span>
        </div>
        

        <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?df74779713027375e7b79302fb72d7b0";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

    </body>
</html>