<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
        <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
        <title>scala语言 - tracholar's personal knowledge wiki</title>
        <meta name="keywords" content="technology, machine learning, data mining, economics, accounting"/>
        <meta name="description" content="A wiki website of tracholar when I learned new knowledgy and technics."/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width" />

        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$(',')$'], ['\\(','\\)']]}
        });
        </script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-78529611-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/wiki/">Home</a>&nbsp;»&nbsp;<a href="/wiki/#tools">tools</a>&nbsp;»&nbsp;scala语言</div>
</div>
<div class="clearfix"></div>
<div id="title">scala语言</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">关于</a></li>
<li><a href="#_2">基础语法</a></li>
<li><a href="#_3">基本数据结构</a><ul>
<li><a href="#functional-combinators">函数组合子 Functional Combinators</a></li>
<li><a href="#_4">函数组合</a></li>
<li><a href="#_5">偏函数</a></li>
</ul>
</li>
<li><a href="#_6">类型，静态类型</a></li>
<li><a href="#_7">隐式转换</a><ul>
<li><a href="#_8">隐式函数</a></li>
<li><a href="#210">隐式类 2.10.+</a></li>
</ul>
</li>
<li><a href="#sbt">构建工具 SBT</a></li>
<li><a href="#-">字符串 - 核心数据结构</a><ul>
<li><a href="#string-interpolationscala-210">字符串插值 String Interpolation，Scala 2.10.+</a></li>
</ul>
</li>
<li><a href="#-_1">集合 - 核心数据结构</a><ul>
<li><a href="#list">List</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#seq">Seq</a></li>
<li><a href="#map">Map</a></li>
</ul>
</li>
<li><a href="#_9">层次结构</a><ul>
<li><a href="#_10">常用子类</a></li>
<li><a href="#_11">一些描述特性的特质</a></li>
<li><a href="#vs">可变 vs 不可变</a></li>
<li><a href="#_12">可变集合</a></li>
<li><a href="#java">与Java转换</a></li>
</ul>
</li>
<li><a href="#specs">使用specs进行测试</a></li>
<li><a href="#_13">并发编程*</a><ul>
<li><a href="#_14">线程安全的三种工具。</a></li>
</ul>
</li>
<li><a href="#javajavascala">Java跨平台交互：在Java中使用Scala</a><ul>
<li><a href="#_15">扩展规格</a></li>
</ul>
</li>
<li><a href="#test">Test</a></li>
</ul>
</div>
<h2 id="_1">关于</h2>
<p>学习scala后，发现scala就是灵活版的java，他通过引入函数式编程的一些概念来达到这个目的，
并且由于基于JVM，能够复用所有的java库！！如果你嫌java臃肿，不妨试试scala。</p>
<h2 id="_2">基础语法</h2>
<ul>
<li>不变量<code>val</code>，变量<code>var</code></li>
<li>基础类型：<ul>
<li>Int</li>
</ul>
</li>
<li>流程控制，直接看例子</li>
</ul>
<div class="hlcode"><pre><span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">100</span><span class="o">){</span>
    <span class="n">println</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>


<ul>
<li><code>def</code>创建函数，类型标签</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">addOne</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>


<ul>
<li>匿名函数 <code>(x:Int) =&gt; x+1</code></li>
<li>函数的部分应用</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">adder</span><span class="o">(</span><span class="n">m</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
<span class="k">val</span> <span class="n">add2</span> <span class="k">=</span> <span class="n">adder</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="k">_:</span><span class="kt">Int</span><span class="o">)</span>
</pre></div>


<ul>
<li>柯理化函数</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">muliply</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span>
</pre></div>


<ul>
<li>可变长参数</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">cap</span><span class="o">(</span><span class="n">args</span> <span class="nc">String</span><span class="o">*)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">args</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
        <span class="n">arg</span> <span class="k">=&gt;</span> <span class="n">arg</span><span class="o">.</span><span class="n">capitalize</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>类 <code>class</code></li>
<li>构造函数不是特殊的方法，他们是除了类的方法定义之外的代码。</li>
</ul>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Calculator</span><span class="o">(</span><span class="n">brand</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="cm">/**</span>
<span class="cm">   * A constructor.</span>
<span class="cm">   */</span>
  <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">brand</span> <span class="o">==</span> <span class="s">&quot;TI&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="s">&quot;blue&quot;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">brand</span> <span class="o">==</span> <span class="s">&quot;HP&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="s">&quot;black&quot;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="s">&quot;white&quot;</span>
  <span class="o">}</span>

  <span class="c1">// An instance method.</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>Scala是高度面向表达式的：大多数东西都是表达式而非指令。</li>
<li>继承</li>
</ul>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">ScientificCalculator</span><span class="o">(</span><span class="n">brand</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Calculator</span><span class="o">(</span><span class="n">brand</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">base</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="o">(</span><span class="n">base</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>抽象类</li>
</ul>
<div class="hlcode"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Shape</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">getArea</span><span class="o">()</span><span class="k">:</span><span class="kt">Int</span>    <span class="c1">// subclass should define this</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>
<p>Traits 特质
很像接口，通过<code>with</code>关键字，一个类可以扩展多个特质。</p>
<p>```scala
trait Car {
  val brand: String
}</p>
<p>trait Shiny {
  val shineRefraction: Int
}
class BMW extends Car with Shiny {
  val brand = "BMW"
  val shineRefraction = 12
}
```
- 泛型，方法和trait都可以引入类型参数</p>
</li>
</ul>
<div class="hlcode"><pre><span class="k">trait</span> <span class="nc">Cache</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">K</span><span class="o">)</span><span class="k">:</span> <span class="kt">V</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">K</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">V</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">K</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">remove</span><span class="o">[</span><span class="kt">K</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">K</span><span class="o">)</span>
</pre></div>


<p>如何实现像java那样的父类占位符。</p>
<ul>
<li>apply方法</li>
</ul>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Bar</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">()</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">bar</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Bar</span>
<span class="n">bar</span><span class="o">()</span>
<span class="c1">// res: Int = 0</span>
</pre></div>


<ul>
<li>单例对象，工厂模式</li>
</ul>
<div class="hlcode"><pre><span class="k">object</span> <span class="nc">Timer</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">currentCount</span><span class="o">()</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">count</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="nc">Timer</span><span class="o">.</span><span class="n">currentCount</span><span class="o">()</span>
</pre></div>


<ul>
<li>函数即对象.
函数是一些特质的集合。具体来说，具有一个参数的函数是Function1特质的一个实例。这个特征定义了apply()语法糖，让你调用一个对象时就像你在调用一个函数。</li>
</ul>
<div class="hlcode"><pre><span class="k">object</span> <span class="nc">addOne</span> <span class="k">extends</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">AddOne</span> <span class="k">extends</span> <span class="o">(</span><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>包，和Java的一样</li>
<li>模式匹配
匹配值</li>
</ul>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">times</span> <span class="k">=</span> <span class="mi">1</span>

<span class="n">times</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">&quot;one&quot;</span>
    <span class="k">case</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">&quot;two&quot;</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;some others&quot;</span>
<span class="o">}</span>

<span class="n">times</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">&quot;one&quot;</span>
    <span class="k">case</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">&quot;two&quot;</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;some others&quot;</span>
<span class="o">}</span>
</pre></div>


<p>匹配类型</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">bigger</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">o</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="kt">i</span> <span class="kt">&lt;</span> <span class="err">0</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span> <span class="kt">if</span> <span class="kt">d</span> <span class="kt">&lt;</span> <span class="err">0</span><span class="kt">.</span><span class="err">0</span> <span class="o">=&gt;</span> <span class="n">d</span> <span class="o">-</span> <span class="mf">0.1</span>
    <span class="k">case</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="n">d</span> <span class="o">+</span> <span class="mf">0.1</span>
    <span class="k">case</span> <span class="n">text</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">text</span> <span class="o">+</span> <span class="s">&quot;s&quot;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>匹配类成员</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">calcType</span><span class="o">(</span><span class="n">calc</span><span class="k">:</span> <span class="kt">Calculator</span><span class="o">)</span> <span class="k">=</span> <span class="n">calc</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">calc</span><span class="o">.</span><span class="n">brand</span> <span class="o">==</span> <span class="s">&quot;hp&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">calc</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s">&quot;20B&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;financial&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">calc</span><span class="o">.</span><span class="n">brand</span> <span class="o">==</span> <span class="s">&quot;hp&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">calc</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s">&quot;48G&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;scientific&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">calc</span><span class="o">.</span><span class="n">brand</span> <span class="o">==</span> <span class="s">&quot;hp&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">calc</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s">&quot;30B&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;business&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;unknown&quot;</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>样本类 case class</li>
</ul>
<div class="hlcode"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Calculator</span><span class="o">(</span><span class="n">brand</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">model</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div>


<p>case classes are designed to be used with pattern matching. Let’s simplify our calculator classifier example from earlier.
样本类就是被设计用在模式匹配中的。让我们简化之前的计算器分类器的例子。</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">calcType</span><span class="o">(</span><span class="n">calc</span><span class="k">:</span> <span class="kt">Calculator</span><span class="o">)</span> <span class="k">=</span> <span class="n">calc</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Calculator</span><span class="o">(</span><span class="s">&quot;hp&quot;</span><span class="o">,</span> <span class="s">&quot;20B&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;financial&quot;</span>
  <span class="k">case</span> <span class="nc">Calculator</span><span class="o">(</span><span class="s">&quot;hp&quot;</span><span class="o">,</span> <span class="s">&quot;48G&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;scientific&quot;</span>
  <span class="k">case</span> <span class="nc">Calculator</span><span class="o">(</span><span class="s">&quot;hp&quot;</span><span class="o">,</span> <span class="s">&quot;30B&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;business&quot;</span>
  <span class="k">case</span> <span class="nc">Calculator</span><span class="o">(</span><span class="n">ourBrand</span><span class="o">,</span> <span class="n">ourModel</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;Calculator: %s %s is of unknown type&quot;</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">ourBrand</span><span class="o">,</span> <span class="n">ourModel</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>


<p>我们也可以将匹配的值重新命名。</p>
<div class="hlcode"><pre>  <span class="k">case</span> <span class="n">c</span><span class="nd">@Calculator</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;Calculator: %s of unknown type&quot;</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
</pre></div>


<ul>
<li>异常， try ... catch ... finally</li>
<li>private[spark] private 作用域为包含spark类的地方才可见</li>
</ul>
<h2 id="_3">基本数据结构</h2>
<ul>
<li>String 实际上就是java.lang.String</li>
<li>List 列表</li>
</ul>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">numbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">)</span>
</pre></div>


<ul>
<li>Set 集</li>
</ul>
<div class="hlcode"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>


<ul>
<li>Tuple 元组</li>
</ul>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">hostPort</span> <span class="k">=</span> <span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">80</span><span class="o">)</span>
<span class="n">hostPort</span><span class="o">.</span><span class="n">_1</span>  <span class="c1">// localhost</span>
<span class="n">hostPort</span><span class="o">.</span><span class="n">_2</span>  <span class="c1">// 80</span>
</pre></div>


<p>与样本类不同，元组不能通过名称获取字段，而是使用位置下标来读取对象；而且这个下标基于1，而不是基于0。
在创建两个元素的元组时，可以使用特殊语法：<code>1 -&gt; 2</code>，见映射
- Map 映射，类似于python的字典，c的hash_map</p>
<div class="hlcode"><pre><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// 值映射</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;bar&quot;</span><span class="o">)</span>  <span class="c1">// 字符串映射</span>
<span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;bar&quot;</span><span class="o">))</span>  <span class="c1">// 映射到映射</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">&quot;timesTwo&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="n">timesTwo</span><span class="o">(</span><span class="k">_</span><span class="o">)})</span>   <span class="c1">// 映射到函数</span>
</pre></div>


<p><code>Map</code>中要获取键对应的值，需要使用<code>Map.get</code>方法。
- 选项 Option
Option 是一个表示有可能包含值的容器。
Option 本身是泛型的，有两个子类 <code>Some[T]</code> 或 <code>None</code>。
在模式匹配中会用到。</p>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">res1</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="o">*</span><span class="mi">2</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div>


<p>Option基本的接口是这样的：</p>
<div class="hlcode"><pre><span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">isDefined</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">getOrElse</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</pre></div>


<p>Option本身是泛型的，并且有两个子类： Some[T] 或 None。
<code>Map.get</code>使用<code>Option</code>作为其返回值，表示这个方法也许不会
返回你请求的值。
类似于Haskell的<code>Maybe</code>？</p>
<h3 id="functional-combinators">函数组合子 Functional Combinators</h3>
<ul>
<li>map 组合子
例子：<code>List(1,2,3,4) map {i:Int =&gt; i*i}</code>，
或者这样调用</li>
</ul>
<div class="hlcode"><pre><span class="n">numbers</span><span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="n">i</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>


<ul>
<li>foreach， 很像map，但是没有返回值。仅用于有副作用的函数？</li>
</ul>
<div class="hlcode"><pre><span class="n">numbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">((</span><span class="n">i</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>


<ul>
<li>filter，一处任何传入函数计算结果为<code>false</code>的元素。</li>
<li>zip，将两个列表的内容聚合到一个对偶列表中。</li>
</ul>
<div class="hlcode"><pre><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">).</span><span class="n">zip</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span><span class="s">&quot;b&quot;</span><span class="o">,</span><span class="s">&quot;c&quot;</span><span class="o">))</span>  <span class="c1">//[(1,a),(2,b),(3,c)]</span>
</pre></div>


<ul>
<li><code>partition</code>, 使用给定的谓词函数（返回true和false的函数）分割列表，返回tuple</li>
<li><code>find</code>，返回集合中第一个匹配谓词函数的元素</li>
<li><code>drop</code> 和 <code>dropWile</code>，<code>drop</code>删除前i个元素，<code>dropWhile</code>将删除
  元素直到不满足条件为止。</li>
<li>foldLeft， 左折叠。需要传入一个初始值和一个二元函数</li>
<li>foldRight，右折叠</li>
<li>flatten，展平。</li>
<li>flatMap，等价于 flatten . map</li>
</ul>
<h3 id="_4">函数组合</h3>
<ul>
<li><code>compose</code>组合其它函数形成新的函数<code>f(g(x))</code>。</li>
</ul>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">fg</span> <span class="k">=</span> <span class="n">f</span> <span class="k">_</span> <span class="n">compose</span> <span class="n">g</span> <span class="k">_</span>
</pre></div>


<p><code>println</code>是啥？为甚不能组合。
- <code>andThen</code>，与<code>compose</code>很像，只是执行顺序相反，先执行第一个。</p>
<h3 id="_5">偏函数</h3>
<p>不是部分应用函数，篇函数是指只能接受该类型的某些特定的值。
<code>isDefinedAt</code>用来确定该函数能否接受一个给定的参数。</p>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">one</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">&quot;one&quot;</span> <span class="o">}</span>
<span class="n">one</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>   <span class="c1">// true</span>
<span class="n">one</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>   <span class="c1">// false</span>
</pre></div>


<p>PartialFunctions可以使用orElse组成新的函数，得到的PartialFunction反映了是否对给定参数进行了定义。</p>
<div class="hlcode"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">two</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">&quot;two&quot;</span> <span class="o">}</span>
<span class="n">two</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">three</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="mi">3</span> <span class="k">=&gt;</span> <span class="s">&quot;three&quot;</span> <span class="o">}</span>
<span class="n">three</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wildcard</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;something else&quot;</span> <span class="o">}</span>
<span class="n">wildcard</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">partial</span> <span class="k">=</span> <span class="n">one</span> <span class="n">orElse</span> <span class="n">two</span> <span class="n">orElse</span> <span class="n">three</span> <span class="n">orElse</span> <span class="n">wildcard</span>
<span class="n">partial</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">partial</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">something</span> <span class="k">else</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">partial</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">three</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">partial</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">two</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">partial</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">one</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">partial</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">something</span> <span class="k">else</span>
</pre></div>


<h2 id="_6">类型，静态类型</h2>
<ul>
<li>参数化多态，秩1多态性rank-one。下面是一个错误的例子，将会报编译错误。</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A-&gt;List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A-&gt;List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
</pre></div>


<ul>
<li>类型推断
Hindley Milner算法。 Scala编译器为我们做类型推断，
使得可以不明确指定返回类型。</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">id</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span> <span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">id</span><span class="o">(</span><span class="s">&quot;hey&quot;</span><span class="o">)</span>
</pre></div>


<ul>
<li>变性 Variance，如果T'是T的子类，那么Container[T']和Container[T]的关系呢？<ul>
<li>协变， C[T']也是C[T]的子类， [+T]</li>
<li>逆变， C[T']是C[T]的父类， [-T]</li>
<li>不变， 没有关系， [T]</li>
</ul>
</li>
</ul>
<p>逆变的例子，函数特质。参数用父类，调用用子类，表明以父类为类型参数的函数
是以子类为类型参数的函数的子类。有点绕，理解一下。</p>
<ul>
<li>边界，指定泛型的大类型？<code>T &lt;: SomeType</code> 指定T是SomeType的子类。</li>
</ul>
<div class="hlcode"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">cacophony</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">things</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="n">things</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sound</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">sound</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="k">type</span> <span class="kt">parameter</span> <span class="kt">T</span>
       <span class="k">def</span> <span class="n">cacophony</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">things</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="n">things</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sound</span><span class="o">)</span>
                                                        <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">biophony</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Animal</span><span class="o">](</span><span class="n">things</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="n">things</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sound</span><span class="o">)</span>
<span class="n">biophony</span><span class="k">:</span> <span class="err">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Animal</span><span class="err">]</span><span class="o">(</span><span class="kt">things:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="nc">Seq</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">biophony</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="k">new</span> <span class="nc">Chicken</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Bird</span><span class="o">))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">cluck</span><span class="o">,</span> <span class="n">call</span><span class="o">)</span>
</pre></div>


<p><code>T :&gt; SomeType</code> 指定T是SomeType的超类。
List 同样 定义了<code>::[B &gt;: T](x: B)</code> 来返回一个List[B]，例如下面这个例子中，
flock是Bird类型，Bird是Animal的子类。<code>::</code>操作后返回的是超类Animal的列表。</p>
<div class="hlcode"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Animal</span> <span class="o">::</span> <span class="n">flock</span>
<span class="n">res59</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Animal</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Animal</span><span class="k">@</span><span class="mi">11</span><span class="n">f8d3a8</span><span class="o">,</span> <span class="nc">Bird</span><span class="k">@</span><span class="mi">7</span><span class="n">e1ec70e</span><span class="o">,</span> <span class="nc">Bird</span><span class="k">@</span><span class="mi">169</span><span class="n">ea8d2</span><span class="o">)</span>
</pre></div>


<ul>
<li>量化 Quantification。
有时候，不关心类型变量时，可以用通配符取而代之，注意区分变量和类型变量。
个人理解：下面这个例子与类型无关，只与List的接口有关，所以不影响类型推导系统。</li>
</ul>
<p>可以为通配符指定边界。</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">count</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">size</span>
<span class="k">def</span> <span class="n">count</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">size</span>

<span class="k">def</span> <span class="n">hashcodes</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">])</span> <span class="k">=</span> <span class="n">l</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">hashCode</span><span class="o">)</span>
</pre></div>


<ul>
<li>View bounds（type classes）， <code>&lt;%</code>.
在隐式函数可以帮助满足类型推断时，它们允许按需的函数应用。</li>
</ul>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;%</span> <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">addIt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="mi">123</span> <span class="o">+</span> <span class="n">x</span> <span class="o">}</span>
</pre></div>


<ul>
<li>
<p>更多类型限制，我已经晕了，不要问我，自己看教程！</p>
</li>
<li>
<p>关于类型，还有一些内容，看教程 <a href="https://twitter.github.io/scala_school/zh_cn/advanced-types.html">https://twitter.github.io/scala_school/zh_cn/advanced-types.html</a></p>
</li>
<li>
<p>断言assert和require，通常用require做参数检查，而用assert做测试相关的。</p>
</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">assert</span><span class="o">(</span><span class="n">assertion</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">assertion</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">AssertionError</span><span class="o">(</span><span class="s">&quot;assertion failed&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">assume</span><span class="o">(</span><span class="n">assumption</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">assumption</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">AssertionError</span><span class="o">(</span><span class="s">&quot;assumption failed&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">require</span><span class="o">(</span><span class="n">requirement</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">requirement</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;requirement failed&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>


<h2 id="_7">隐式转换</h2>
<h3 id="_8">隐式函数</h3>
<div class="hlcode"><pre><span class="k">implicit</span> <span class="k">def</span> <span class="n">intToString</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">x.toString</span>
</pre></div>


<h3 id="210">隐式类 2.10.+</h3>
<p>隐式类的主方法可以用于隐式类型转换。</p>
<div class="hlcode"><pre><span class="k">object</span> <span class="nc">Helpers</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">IntWithTimes</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">times</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">loop</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
        <span class="k">if</span><span class="o">(</span><span class="n">current</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">f</span>
          <span class="n">loop</span><span class="o">(</span><span class="n">current</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="n">loop</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">import</span> <span class="nn">Helpers._</span>
<span class="mi">5</span> <span class="n">times</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;HI&quot;</span><span class="o">)</span>

<span class="nc">HI</span>
<span class="nc">HI</span>
<span class="nc">HI</span>
<span class="nc">HI</span>
<span class="nc">HI</span>
</pre></div>


<h2 id="sbt">构建工具 SBT</h2>
<ul>
<li>安装命令<code>brew install sbt</code></li>
<li>项目布局<ul>
<li>项目 – 项目定义文件<ul>
<li>project/build/.scala – 主项目定义文件</li>
<li>project/build.properties – 项目、sbt和Scala版本定义</li>
<li>src/main – 你的应用程序代码出现在这里，在子目录表明代码的语言（如src/main/scala, src/main/java）</li>
<li>src/main/resources – 你想要添加到jar包中的静态文件（如日志配置）</li>
<li>src/test – 就像src/main，不过是对测试</li>
<li>lib_managed – 你的项目依赖的jar文件。由sbt update时填充</li>
<li>target – 生成物的目标路径（如自动生成的thrift代码，类文件，jar包）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="-">字符串 - 核心数据结构</h2>
<p>scala的字符串很多是直接借助于java的String类，但是还有一些scala的特性需要说明一下。</p>
<h3 id="string-interpolationscala-210">字符串插值 String Interpolation，Scala 2.10.+</h3>
<p>scala提供三种字符串插值方法，s, f and raw。
- s支持局部变量和表达式。
- f表明对变量进行格式化，类似于printf的功能。类型安全，如果不匹配，将会报错。<code>%s</code>是通用的？！
- raw字符串就是不会对转义字符转义。相当于python里面的r</p>
<div class="hlcode"><pre><span class="c1">// 插入局部变量</span>
<span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;James&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Hello, $name&quot;</span><span class="o">)</span>  <span class="c1">// Hello, James</span>
<span class="c1">// 插入表达式</span>
<span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;1 + 1 = ${1 + 1}&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">height</span> <span class="k">=</span> <span class="mf">1.9d</span>
<span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;James&quot;</span>
<span class="c1">// f 使用类似于printf格式字符</span>
<span class="n">println</span><span class="o">(</span><span class="n">f</span><span class="s">&quot;$name%s is $height%2.2f meters tall&quot;</span><span class="o">)</span>  <span class="c1">// James is 1.90 meters tall</span>

<span class="n">println</span><span class="o">(</span><span class="n">raw</span><span class="s">&quot;a\nb&quot;</span><span class="o">)</span> <span class="c1">// Output: a\nb</span>
</pre></div>


<h2 id="-_1">集合 - 核心数据结构</h2>
<h3 id="list">List</h3>
<ul>
<li>创建集合</li>
</ul>
<div class="hlcode"><pre><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">)</span>
<span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>

<span class="k">val</span> <span class="n">L</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span> <span class="n">toList</span>
</pre></div>


<p><code>::</code>是将前面的数据prepend到后面的列表中，等同于<code>+:</code>。</p>
<ul>
<li>
<p>连接集合， <code>L1 ++ L2</code>， 可以连接元素类型不同的集合，最终生成的集合类型是这两个
  集合元素类型的超集。和<code>:::</code>一样</p>
</li>
<li>
<p><code>z /: L</code> 相当于 <code>foldLeft z L</code>, <code>(0 /: L)((a,b)=&gt;a+b)</code>求和</p>
</li>
<li><code>z :\ L</code> 右折叠</li>
<li>
<p><code>:+</code> append操作， <code>L :+ 6</code></p>
</li>
<li>
<p>索引操作：<code>.apply(n:Int)</code> 取下标n的元素，可以通过<code>()</code>进行访问，如<code>L(0)</code></p>
</li>
<li>内置的数学函数，<code>.max</code>, <code>.min</code>, <code>.sum</code>, <code>.product</code></li>
<li>内置的基本属性，<code>.length</code>, <code>.size</code>, <code>.head</code>, <code>.last</code></li>
<li><code>filter</code>, <code>flatMap</code>, <code>map</code>, <code>withFilter</code>, <code>zip</code>, <code>zipWithIndex</code>（相当于python的enumerater）。
  其中<code>flatMap = flatten . map</code>，因此穿进去的函数需要返回一个<code>GenTraversableOnce</code>，比如返回一个列表。</li>
</ul>
<h3 id="set">Set</h3>
<ul>
<li><code>+</code> 增加一个元素，返回新的集合</li>
<li><code>-</code> 减少一个元素</li>
<li><code>&amp;</code> 交集 <code>|</code> 并集（<code>++</code>） <code>&amp;~</code> 差集 (<code>--</code>)</li>
<li>与list一样的折叠、map、reduce等集合相关操作</li>
<li>索引<code>apply(e:A)</code>，<code>(e:A)</code>一样</li>
</ul>
<h3 id="seq">Seq</h3>
<p>貌似与list没啥区别，需要再仔细看看。</p>
<div class="hlcode"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>


<p>请注意返回的是一个列表。因为Seq是一个特质；而列表是序列的很好实现。</p>
<p>".mkString(seq)" 方法可以实现python的<code>join</code>方法的功能。</p>
<h3 id="map">Map</h3>
<ul>
<li>创建MAP</li>
</ul>
<div class="hlcode"><pre><span class="n">Map</span><span class="p">(</span><span class="sc">&#39;a&#39;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>


<h2 id="_9">层次结构</h2>
<ul>
<li>
<p>traverable, <code>foreach</code> 实现遍历</p>
<ul>
<li>基本操作<ul>
<li><code>def head : A</code> 返回第一个元素</li>
<li><code>def tail : Traversable[A]</code> 除去第一个元素剩下的集合</li>
</ul>
</li>
<li>
<p>函数组合子</p>
<ul>
<li><code>def map [B] (f: (A) =&gt; B) : CC[B]</code> 返回每个元素都被 f 转化的集合</li>
<li><code>def foreach[U](f: Elem =&gt; U): Unit</code> 在集合中的每个元素上执行 f 。</li>
<li><code>def find (p: (A) =&gt; Boolean) : Option[A]</code> 返回匹配谓词函数的第一个元素</li>
<li><code>def filter (p: (A) =&gt; Boolean) : Traversable[A]</code> 返回所有匹配谓词函数的元素集合</li>
</ul>
</li>
<li>
<p>划分：</p>
<ul>
<li><code>def partition (p: (A) =&gt; Boolean) : (Traversable[A], Traversable[A])</code> 按照谓词函数把一个集合分割成两部分</li>
<li><code>def groupBy [K] (f: (A) =&gt; K) : Map[K, Traversable[A]]</code> 按照Key函数将一个集合分为多个. <code>S.groupBy(x=&gt;x%3)</code></li>
</ul>
</li>
<li>转换：<ul>
<li><code>def toArray : Array[A]</code></li>
<li><code>def toArray [B &gt;: A] (implicit arg0: ClassManifest[B]) : Array[B]</code></li>
<li><code>def toBuffer [B &gt;: A] : Buffer[B]</code></li>
<li><code>def toIndexedSeq [B &gt;: A] : IndexedSeq[B]</code></li>
<li><code>def toIterable : Iterable[A]</code></li>
<li><code>def toIterator : Iterator[A]</code></li>
<li><code>def toList : List[A]</code></li>
<li><code>def toMap [T, U] (implicit ev: &lt;:&lt;[A, (T, U)]) : Map[T, U]</code> 例如转换命令行参数，<code>List("A=3","B=5").map(l =&gt; l.split("=")).toMap</code></li>
<li><code>def toSeq : Seq[A]</code></li>
<li><code>def toSet [B &gt;: A] : Set[B]</code></li>
<li><code>def toStream : Stream[A]</code></li>
<li><code>def toString () : String</code></li>
<li><code>def toTraversable : Traversable[A]</code></li>
</ul>
</li>
<li>iterable, <code>iterator()</code> 返回一个迭代器，通常不会用，一般会用函数组合子和<code>for</code></li>
</ul>
</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">hasNext</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">next</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span>
</pre></div>


<ul>
<li>Seq 序列，有顺序的对象序列</li>
<li>Set 没有重复的对象集合</li>
</ul>
<div class="hlcode"><pre><span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="o">+(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="o">-(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</pre></div>


<ul>
<li>Map 键值对</li>
</ul>
<h3 id="_10">常用子类</h3>
<ul>
<li>HashSet: implements immutable sets using a <strong> hash trie </strong></li>
<li>HashMap: implements immutable maps using a hash trie</li>
<li>TreeMap 是SortedMap子类</li>
<li>Vector 快速随机访问
    继承 <code>Seq</code>, <code>IndexedSeq</code>, <code>Iterable</code>, <code>Traversable</code></li>
<li>Range 等间隔的Int有序序列。
    继承 <code>traverable</code>, <code>Iterable</code>, <code>Seq</code>.</li>
</ul>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">r0</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">10</span>
<span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">10</span> <span class="n">by</span> <span class="mi">2</span>
<span class="k">new</span> <span class="nc">Range</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div>


<h3 id="_11">一些描述特性的特质</h3>
<ul>
<li><code>IndexedSeq</code> 快速随机访问元素和一个快速的长度操作</li>
<li><code>LinearSeq</code> 通过head快速访问第一个元素，也有一个快速的tail操作。</li>
</ul>
<h3 id="vs">可变 vs 不可变</h3>
<p>不可变</p>
<p>优点</p>
<p>在多线程中不会改变
缺点</p>
<p>一点也不能改变
Scala允许我们是务实的，它鼓励不变性，但不惩罚我们需要的可变性。这和var vs. val非常相似。我们总是先从val开始并在必要时回退为var。</p>
<p>我们赞成使用不可改变的版本的集合，但如果性能使然，也可以切换到可变的。使用不可变集合意味着你在多线程不会意外地改变事物。</p>
<h3 id="_12">可变集合</h3>
<ul>
<li>ListBuffer和ArrayBuffer</li>
<li>LinkedList and DoubleLinkedList</li>
<li>PriorityQueue</li>
<li>Stack 和 ArrayStack</li>
<li>StringBuilder 有趣的是，StringBuilder的是一个集合</li>
</ul>
<h3 id="java">与Java转换</h3>
<p>您可以通过JavaConverters package轻松地在Java和Scala的集合类型之间转换。它用asScala 装饰常用的Java集合以和用asJava 方法装饰Scala集合。</p>
<div class="hlcode"><pre>   <span class="k">import</span> <span class="nn">scala.collection.JavaConverters._</span>
   <span class="k">val</span> <span class="n">sl</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
   <span class="k">val</span> <span class="n">jl</span> <span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">sl</span><span class="o">.</span><span class="n">asJava</span>
   <span class="k">val</span> <span class="n">sl2</span> <span class="k">:</span> <span class="kt">scala.collection.mutable.Buffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">jl</span><span class="o">.</span><span class="n">asScala</span>
   <span class="n">assert</span><span class="o">(</span><span class="n">sl</span> <span class="n">eq</span> <span class="n">sl2</span><span class="o">)</span>
</pre></div>


<p>双向转换：</p>
<div class="hlcode"><pre><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Iterable</span> <span class="o">&lt;=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Iterable</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Iterable</span> <span class="o">&lt;=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Collection</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Iterator</span> <span class="o">&lt;=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.{</span> <span class="nc">Iterator</span><span class="o">,</span> <span class="nc">Enumeration</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Buffer</span> <span class="o">&lt;=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span> <span class="o">&lt;=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Set</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span> <span class="o">&lt;=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.{</span> <span class="nc">Map</span><span class="o">,</span> <span class="nc">Dictionary</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ConcurrentMap</span> <span class="o">&lt;=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">ConcurrentMap</span>
</pre></div>


<p>此外，也提供了以下单向转换</p>
<div class="hlcode"><pre><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Seq</span> <span class="k">=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Seq</span> <span class="k">=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Set</span> <span class="k">=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Set</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Map</span> <span class="k">=&gt;</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Map</span>
</pre></div>


<h2 id="specs">使用specs进行测试</h2>
<p>貌似现在包为specs2，导入单元测试规范<code>org.specs2.mutable.Specification</code></p>
<div class="hlcode"><pre><span class="n">org</span><span class="o">.</span><span class="n">specs2</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="k">_</span>

<span class="k">object</span> <span class="nc">ArithmeticSpec</span> <span class="k">extends</span> <span class="nc">Specification</span> <span class="o">{</span>
  <span class="s">&quot;Arithmetic&quot;</span> <span class="n">should</span> <span class="o">{</span>
    <span class="s">&quot;add two numbers&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">mustEqual</span> <span class="mi">2</span>
    <span class="o">}</span>
    <span class="s">&quot;add three numbers&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">mustEqual</span> <span class="mi">3</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h2 id="_13">并发编程*</h2>
<ul>
<li>Runnable/Callable定义如下，区别在于Runnable没有返回值，而Callable有。</li>
</ul>
<div class="hlcode"><pre><span class="k">trait</span> <span class="nc">Runnable</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Callable</span><span class="o">[</span><span class="kt">V</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">call</span><span class="o">()</span><span class="k">:</span> <span class="kt">V</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>线程，Scala并发是建立在Java并发模型基础上的。在Sun JVM上，对IO密集的任务，我们可以在一台机器运行成千上万个线程。
  一个线程需要一个<code>Runnable</code>。你必须调用线程的 <code>start</code> 方法来运行Runnable。</li>
</ul>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">hello</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;hello world&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">})</span>

<span class="n">hello</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>
</pre></div>


<p>创建一个自己的线程步骤，首先创建一个实现Runnable接口的类，然后将该类的实例作为参数传给<code>new Thread()</code>即可，
然后再调用创建的线程的<code>.start()</code>方法就可以运行了。</p>
<p>也可以利用java的线程的执行服务构建一个线程池。<code>java.util.concurrent.{Executors, ExecutorService}</code></p>
<div class="hlcode"><pre><span class="k">val</span> <span class="n">pool</span><span class="k">:</span> <span class="kt">ExecutorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="n">newFixedThreadPool</span><span class="o">(</span><span class="n">poolSize</span><span class="o">)</span>
<span class="n">pool</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRunableClass</span><span class="o">())</span>
</pre></div>


<ul>
<li>Futures. Future 代表异步计算。你可以把你的计算包装在Future中，当你需要计算结果的时候，你只需调用一个阻塞的 get() 方法就可以了。一个 Executor 返回一个 Future 。</li>
</ul>
<h3 id="_14">线程安全的三种工具。</h3>
<ul>
<li>mutex 互斥锁。</li>
<li>volatile</li>
<li>AtomicReference</li>
</ul>
<div class="hlcode"><pre><span class="c1">// synchronized</span>
<span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">var</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">changedName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">synchronized</span> <span class="o">{</span>
      <span class="n">name</span> <span class="k">=</span> <span class="n">changedName</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// volatile</span>
<span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="nd">@volatile</span> <span class="k">var</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">changedName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">name</span> <span class="k">=</span> <span class="n">changedName</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AtomicReference</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicReference</span>

<span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">AtomicReference</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">changedName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">name</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="n">changedName</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>略</p>
<h2 id="javajavascala">Java跨平台交互：在Java中使用Scala</h2>
<h3 id="_15">扩展规格</h3>
<h2 id="test">Test</h2>
<p>包 <code>http://www.scalatest.org/</code></p>
</div>
<div id="content-footer">created in <span class="create-date date"> 2016-07-05 </span></div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2016 tracholar.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
                Fork me in <a href="https://github.com/tracholar/wiki" target="_blank"> github </a>.
            </span>
        </div>
        
    </body>
</html>